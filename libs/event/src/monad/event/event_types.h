#pragma once

// DO NOT EDIT THIS FILE! If you need changes, change the code generator
// instead. This file was generated by running the following command:
//
//    ../../python/cg-events c -p .

/**
 * @file
 *
 * Core definitions of event enumeration types and event payload structures
 */

#include <stdint.h>

// clang-format off
#ifdef __cplusplus

#include <string.h>

struct evmc_address;
struct evmc_bytes32;

extern "C"
{
#endif

typedef struct monad_event_address
{
    uint8_t bytes[20];

#ifdef __cplusplus
    monad_event_address &operator=(evmc_address const &rhs)
    {
        memcpy(this, &rhs, sizeof *this);
        return *this;
    }
#endif
} monad_event_address;

typedef struct monad_event_bytes32
{
    uint8_t bytes[32];

#ifdef __cplusplus
    monad_event_bytes32 &operator=(evmc_bytes32 const &rhs)
    {
        memcpy(this, &rhs, sizeof *this);
        return *this;
    }
#endif
} monad_event_bytes32;

// 256-bit integer stored in native endian byte order; the rationale for the
// storage layout as `uint64_t[4]` instead of `uint8_t[32]` is that this
// ensures the type is suitably-aligned to unsafely cast the underlying bits
// into a type in an extended-precision integer library, if that library
// internally uses a uint64_t[4] "limbs"-styleÂ representation. Both the C++
// intx library and Rust's ruint package use this representation.
typedef struct monad_event_uint256_ne
{
    uint64_t limbs[4];

#ifdef __cplusplus
    monad_event_uint256_ne &operator=(evmc_bytes32 const &rhs)
    {
        memcpy(this, &rhs, sizeof *this);
        return *this;
    }
#endif
} monad_event_uint256_ne;

/// Each type of event is assigned a unique value in this enumeration
enum monad_event_type : uint16_t
{
    MONAD_EVENT_NONE,
    MONAD_EVENT_RING_INIT,
    MONAD_EVENT_THREAD_CREATE,
    MONAD_EVENT_THREAD_EXIT,
    MONAD_EVENT_TEST_COUNTER,
    MONAD_EVENT_BLOCK_START,
};

/// Event payload for MONAD_EVENT_THREAD_CREATE
struct monad_event_thread_info
{
    uint64_t epoch_nanos;
    uint64_t process_id;
    uint64_t thread_id;
    uint8_t source_id;
    char thread_name[31];
};

/// Event payload for MONAD_EVENT_TEST_COUNTER
struct monad_event_test_counter
{
    uint8_t writer_id;
    uint64_t counter;
};

/// Event payload for MONAD_EVENT_BLOCK_START
struct monad_event_block_exec_header
{
    monad_event_bytes32 bft_block_id;
    uint64_t round;
    uint64_t parent_round;
    uint64_t consensus_seqno;
    monad_event_bytes32 ommers_hash;
    monad_event_address beneficiary;
    uint64_t difficulty;
    uint64_t number;
    uint64_t gas_limit;
    uint64_t timestamp;
    uint64_t extra_data_length;
    monad_event_bytes32 extra_data;
    monad_event_bytes32 mix_hash;
    uint8_t nonce[8];
    monad_event_uint256_ne base_fee_per_gas;
    uint64_t blob_gas_used;
    uint64_t excess_blob_gas;
    monad_event_bytes32 parent_beacon_block_root;
    uint64_t txn_count;
};

#ifdef __cplusplus
} // extern "C"

// clang-format on
#endif
