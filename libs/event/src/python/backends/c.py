import argparse
import ctypes
import pathlib
import sys
import textwrap
import typing

from event_ctypes import *
from event import EventInfo, hash_events

#
# event_types.h content and functions
#

HEADER_PROLOGUE = \
"""#pragma once

// DO NOT EDIT THIS FILE! If you need changes, change the code generator
// instead. This file was generated by running the following command:
//
{0}

/**
 * @file
 *
 * Core definitions of event enumeration types and event payload structures
 */

#include <stdint.h>

// clang-format off
#ifdef __cplusplus

#include <string.h>

struct evmc_address;
struct evmc_bytes32;

extern "C"
{{
#endif

typedef struct monad_event_address
{{
    uint8_t bytes[20];

#ifdef __cplusplus
    monad_event_address &operator=(evmc_address const &rhs)
    {{
        memcpy(this, &rhs, sizeof *this);
        return *this;
    }}
#endif
}} monad_event_address;

typedef struct monad_event_bytes32
{{
    uint8_t bytes[32];

#ifdef __cplusplus
    monad_event_bytes32 &operator=(evmc_bytes32 const &rhs)
    {{
        memcpy(this, &rhs, sizeof *this);
        return *this;
    }}
#endif
}} monad_event_bytes32;

// 256-bit integer stored in native endian byte order; the rationale for the
// storage layout as `uint64_t[4]` instead of `uint8_t[32]` is that this
// ensures the type is suitably-aligned to unsafely cast the underlying bits
// into a type in an extended-precision integer library, if that library
// internally uses a uint64_t[4] "limbs"-styleÂ representation. Both the C++
// intx library and Rust's ruint package use this representation.
typedef struct monad_event_uint256_ne
{{
    uint64_t limbs[4];

#ifdef __cplusplus
    monad_event_uint256_ne &operator=(evmc_bytes32 const &rhs)
    {{
        memcpy(this, &rhs, sizeof *this);
        return *this;
    }}
#endif
}} monad_event_uint256_ne;
"""

HEADER_EPILOGUE = \
"""#ifdef __cplusplus
} // extern "C"

// clang-format on
#endif"""

TypeMap = {
  address : 'monad_event_address',
  bytes32 : 'monad_event_bytes32',
  transaction_type : 'uint8_t',
  uint256_ne : 'monad_event_uint256_ne',
  ctypes.c_char : 'char',
  ctypes.c_uint8 : 'uint8_t',
  ctypes.c_uint16 : 'uint16_t',
  ctypes.c_uint32 : 'uint32_t',
  ctypes.c_uint64 : 'uint64_t',
  ctypes.c_long : 'long'
}

def create_command_comment() -> str:
  cmdline = ' '.join(sys.argv)
  invoke_lines = (f'//    {line}' for line in textwrap.wrap(cmdline))
  return '\n'.join(invoke_lines)

def emit_header_prologue(out: typing.TextIO):
  cmdline = ' '.join(sys.argv)
  invoke_lines = (f'//    {line}' for line in textwrap.wrap(cmdline))
  print(HEADER_PROLOGUE.format(create_command_comment()), file=out)

def emit_header_epilogue(out: typing.TextIO):
  print(HEADER_EPILOGUE, file=out)

def emit_enum_type(events: list[EventInfo], out: typing.TextIO):
  print(
"""/// Each type of event is assigned a unique value in this enumeration
enum monad_event_type : uint16_t
{""", file=out)

  for event in events:
    print(f'    MONAD_EVENT_{event.c_name},', file=out)

  print('};\n', file=out)

def emit_payload_types(events: list[EventInfo], out: typing.TextIO):
  for event in events:
    if not event.payload_type or \
       not issubclass(event.payload_type, ctypes.Structure):
      continue
    print(
"""/// Event payload for MONAD_EVENT_{0}
struct monad_event_{1}
{{""".format(event.c_name, event.payload_type.__name__), file=out)
    for name, ctype in event.payload_type._fields_:
      ty = TypeMap.get(ctype, None)
      if ty is None and issubclass(ctype, ctypes.Array):
        elem_ty = TypeMap.get(ctype._type_, None)
        if not elem_ty:
          raise NotImplementedError('do not how to choose C type for array '
                                    f'`{event.payload_type.__name__}::{name}` '
                                    f'ctype: {ctype._type_.__name__}')
        print(f'    {elem_ty} {name}[{ctype._length_}];', file=out)
      elif ty is None:
        raise NotImplementedError('do not know how to choose C type for '
                                  f'{event.payload_type.__name__}::{name}')
      else:
        print(f'    {ty} {name};', file=out)
    print('};\n', file=out)

def emit_header_file(events: list[EventInfo], out: typing.TextIO):
  emit_header_prologue(out)
  emit_enum_type(events, out)
  emit_payload_types(events, out)
  emit_header_epilogue(out)

#
# event_metadata.c content and functions
#

METADATA_PROLOGUE = \
"""// DO NOT EDIT THIS FILE! If you need changes, change the code generator
// instead. This file was generated by running the following command:
//
{0}

#include <stddef.h>

#include <monad/event/event.h>
#include <monad/event/event_metadata.h>

#ifdef __cplusplus
extern "C"
{{
#endif

// clang-format off
"""

METADATA_EPILOGUE = \
"""
#ifdef __cplusplus
} // extern "C"
#endif"""

def emit_metadata_prologue(out: typing.TextIO):
  print(METADATA_PROLOGUE.format(create_command_comment()), file=out)

def emit_metadata_epilogue(out: typing.TextIO):
  print(METADATA_EPILOGUE, file=out)

def emit_metadata_array(events: list[EventInfo], out: typing.TextIO):
  print('struct monad_event_metadata const g_monad_event_metadata[] = {', file=out)
  for enum_code, event in enumerate(events):
    print(file=out) # Skip a line
    print(f'    [MONAD_EVENT_{event.c_name}] =', file=out)
    print(f'        {{.type = MONAD_EVENT_{event.c_name},', file=out)
    print(f'         .c_name = "{event.c_name}",', file=out)
    print(f'         .description = "{event.description}"}},', file=out)
  print('};', file=out)

  print(file=out)
  print(f'size_t const g_monad_event_metadata_size = {len(events)};', file=out)

  evt_hash = hash_events(events)
  print(file=out)
  print('uint8_t const g_monad_event_metadata_hash[32] = {', file=out)
  for b in range(0, 32, 8):
    hash_initializer = ', '.join(f'0x{b:02x}' for b in evt_hash[b:b+8])
    print(f'    {hash_initializer},', file=out)
  print('};', file=out)

def emit_metadata_file(events: list[EventInfo], out: typing.TextIO):
  emit_metadata_prologue(out)
  emit_metadata_array(events, out)
  emit_metadata_epilogue(out)

def c_main(args: argparse.Namespace, events: list[EventInfo]) -> int:
  if args.path and not args.path.is_dir():
    raise ValueError(f'{args.path} is not a valid directory')

  # Emit event_types.h
  HeaderFileName = 'event_types.h'
  if args.stdout:
    print(f'{HeaderFileName} contents:', file=sys.stdout)
    emit_header_file(events, sys.stdout)
  else:
    with open(args.path / HeaderFileName, 'wt') as out:
      emit_header_file(events, out)

  # Emit event_metadata.c
  MetadataFileName = 'event_metadata.c'
  if args.stdout:
    print(f'{MetadataFileName} contents:', file=sys.stdout)
    emit_metadata_file(events, sys.stdout)
  else:
    with open(args.path / MetadataFileName, 'wt') as out:
      emit_metadata_file(events, out)

  return 0

def register_backend(subparsers):
  p = subparsers.add_parser('c', help='generate event sources for the C language')

  output_group = p.add_mutually_exclusive_group(required=True)

  output_group.add_argument('-s', '--stdout', action='store_true',
      help='write C source files to stdout, for debugging')

  output_group.add_argument('-p', '--path', action='store',
      type=pathlib.Path, metavar='<dir>',
      help='output directory where generated source code files will be written')

  p.set_defaults(backend_main=c_main)
