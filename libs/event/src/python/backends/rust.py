import argparse
import ctypes
import pathlib
import sys
import textwrap
import typing

from event_ctypes import *
from event import EventInfo, hash_events

#
# event_types.rs content and functions
#

TYPES_PROLOGUE = \
"""// DO NOT EDIT THIS FILE! If you need changes, change the code generator
// instead. This file was generated by running the following command:
//
{0}

//! Core definitions of event enumeration types and event payload structures

#![allow(non_camel_case_types)]

use alloy_primitives::{{Address, B256, U256}};
"""

TypeMap = {
  address : 'Address',
  bytes32 : 'B256',
  transaction_type : 'u8',
  uint256_ne : 'U256',
  ctypes.c_uint8 : 'u8',
  ctypes.c_uint16 : 'u16',
  ctypes.c_uint32 : 'u32',
  ctypes.c_uint64 : 'u64'
}

def create_command_comment() -> str:
  cmdline = ' '.join(sys.argv)
  invoke_lines = (f'//    {line}' for line in textwrap.wrap(cmdline))
  return '\n'.join(invoke_lines)

def emit_types_prologue(out: typing.TextIO):
  cmdline = ' '.join(sys.argv)
  invoke_lines = (f'//    {line}' for line in textwrap.wrap(cmdline))
  print(TYPES_PROLOGUE.format(create_command_comment()), file=out)

def emit_enum_type(events: list[EventInfo], out: typing.TextIO):
  # Emit the enum head
  print(
"""/// Each type of event is assigned a unique value in this enumeration
#[repr(u16)]
#[derive(Copy, Clone, Debug)]
pub enum monad_event_type {""", file=out)

  for event in events:
    print(f'    {event.c_name},', file=out)

  print('}', file=out)

def emit_payload_types(events: list[EventInfo], out: typing.TextIO):
  for event in events:
    if not event.payload_type or \
       not issubclass(event.payload_type, ctypes.Structure):
      continue

    # Emit the struct head
    print("""
/// Event payload for {0}
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct {1} {{""".format(event.c_name, event.payload_type.__name__), file=out)

    for name, ctype in event.payload_type._fields_:
      ty = TypeMap.get(ctype, None)
      if ty is None and issubclass(ctype, ctypes.Array):
        if ctype._type_ is ctypes.c_char:
          # Strictly speaking char is usually signed, but we don't care; u8
          # is how we would prefer to represent UTF8 in any case
          elem_ty = 'u8'
        else:
          elem_ty = TypeMap.get(ctype._type_, None)
          if not elem_ty:
            raise NotImplementedError('do not how to choose C type for array '
                                      f'`{event.payload_type.__name__}::{name}` '
                                      f'ctype: {ctype._type_.__name__}')
        print(f'    pub {name}: [{elem_ty}; {ctype._length_}],', file=out)
      elif ty is None:
        raise NotImplementedError('do not know how to choose C type for '
                                  f'{event.payload_type.__name__}::{name}')
      else:
        print(f'    pub {name}: {ty},', file=out)
    print('}', file=out)

def emit_types_module_file(events: list[EventInfo], out: typing.TextIO):
  emit_types_prologue(out)
  emit_enum_type(events, out)
  emit_payload_types(events, out)

#
# event_metadata.rs content and functions
#

METADATA_PROLOGUE = \
"""// DO NOT EDIT THIS FILE! If you need changes, change the code generator
// instead. This file was generated by running the following command:
//
{0}

use crate::event_types::monad_event_type;

#[derive(Debug)]
pub struct EventMetadata {{
    pub event_type: monad_event_type,
    pub c_name: &'static str,
    pub description: &'static str,
}}
"""

def emit_metadata_prologue(out: typing.TextIO):
  cmdline = ' '.join(sys.argv)
  invoke_lines = (f'//    {line}' for line in textwrap.wrap(cmdline))
  print(METADATA_PROLOGUE.format(create_command_comment()), file=out)

def emit_metadata_array(events: list[EventInfo], out: typing.TextIO):
  print(f'pub const EVENT_METADATA: [EventMetadata; {len(events)}] = [',
        file=out)
  for event in events:
    print(
"""    EventMetadata {{
        event_type: monad_event_type::{0},
        c_name: "{0}",
        description: "{1}",
    }},""".format(event.c_name, event.description), file=out)
  print('];', file=out)

  evt_hash = hash_events(events)
  print("""
/// libmonad_event_queue_ffi.so expects this symbol to be defined
#[allow(non_upper_case_globals)]
#[no_mangle]
pub static g_monad_event_metadata_hash: [u8; 32] = [""", file=out)
  for b in range(0, 32, 8):
    hash_initializer = ', '.join(f'{b:#02x}' for b in evt_hash[b:b+8])
    print(f'    {hash_initializer},', file=out)
  print('];', file=out)

def emit_metadata_module_file(events: list[EventInfo], out: typing.TextIO):
  emit_metadata_prologue(out)
  emit_metadata_array(events, out)

def rust_main(args: argparse.Namespace, events: list[EventInfo]) -> int:
  if args.path and not args.path.is_dir():
    raise ValueError(f'{args.path} is not a valid directory')

  # Emit event_types.rs
  TypesFileName = 'event_types.rs'
  if args.stdout:
    print(f'{TypesFileName} contents:', file=sys.stdout)
    emit_types_module_file(events, sys.stdout)
  else:
    with open(args.path / TypesFileName, 'wt') as out:
      emit_types_module_file(events, out)

  # Emit event_metadata.rs
  MetadataFileName = 'event_metadata.rs'
  if args.stdout:
    print(f'{MetadataFileName} contents:', file=sys.stdout)
    emit_metadata_module_file(events, sys.stdout)
  else:
    with open(args.path / MetadataFileName, 'wt') as out:
      emit_metadata_module_file(events, out)

  return 0

def register_backend(subparsers):
  p = subparsers.add_parser('rust', help='generate event sources for the Rust language')

  output_group = p.add_mutually_exclusive_group(required=True)

  output_group.add_argument('-s', '--stdout', action='store_true',
      help='write Rust source files to stdout, for debugging')

  output_group.add_argument('-p', '--path', action='store',
      type=pathlib.Path, metavar='<dir>',
      help='output directory where generated source code files will be written')

  p.set_defaults(backend_main=rust_main)
