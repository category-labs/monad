#include <monad/execution/analysis.hpp>

#include <gtest/gtest.h>

#include <evmc/hex.hpp>

#include <vector>

using enum evmone::Opcode;

using namespace evmc::literals;

TEST(Tokenizer, InvalidOpcodes)
{
    // PUSH1 00
    // INVALID
    // PUSH1 00
    // INVALID
    auto const bytecode_string = evmc::from_hex("60001e60002a").value();
    EXPECT_THROW(
        monad::execution::tokenize_code(bytecode_string),
        std::invalid_argument);
}

TEST(Tokenizer, Empty)
{
    auto const opcodes =
        monad::execution::tokenize_code(evmc::from_hex("").value());
    EXPECT_EQ(opcodes, std::vector<monad::execution::Instruction>{});
}

TEST(Tokenizer, EthereumTestTwoOps)
{
    // bytecode trimmed from from
    // ./monad/third_party/ethereum-tests/GeneralStateTests/VMTests/vmArithmeticTest/twoOps.json",

    auto const bytecode_string =
        "6003600160020101661100010001000055600160016002010166110001000100015560"
        "0360016002020166110001000200005560016001600202016611000100020001556003"
        "6001600203016611000100030000556001600160020301661100010003000155600360"
        "0160020401661100010004000055600160016002040166110001000400015560036001"
        "60020501661100010005000055600160016002050166110001000500015560036001";

    auto const bytecode = evmc::from_hex(bytecode_string).value();
    auto const opcodes = monad::execution::tokenize_code(bytecode);

    // expected_opcodes generated by pasting bytecode above into
    // https://www.evm.codes/playground

    std::vector<monad::execution::Instruction> const expected_opcodes{
        {OP_PUSH1, 0x03_bytes32},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x02_bytes32},
        {OP_ADD},
        {OP_ADD},
        {OP_PUSH7, 0x11000100010000_bytes32},
        {OP_SSTORE},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x02_bytes32},
        {OP_ADD},
        {OP_ADD},
        {OP_PUSH7, 0x11000100010001_bytes32},
        {OP_SSTORE},
        {OP_PUSH1, 0x03_bytes32},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x02_bytes32},
        {OP_MUL},
        {OP_ADD},
        {OP_PUSH7, 0x11000100020000_bytes32},
        {OP_SSTORE},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x02_bytes32},
        {OP_MUL},
        {OP_ADD},
        {OP_PUSH7, 0x11000100020001_bytes32},
        {OP_SSTORE},
        {OP_PUSH1, 0x03_bytes32},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x02_bytes32},
        {OP_SUB},
        {OP_ADD},
        {OP_PUSH7, 0x11000100030000_bytes32},
        {OP_SSTORE},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x02_bytes32},
        {OP_SUB},
        {OP_ADD},
        {OP_PUSH7, 0x11000100030001_bytes32},
        {OP_SSTORE},
        {OP_PUSH1, 0x03_bytes32},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x02_bytes32},
        {OP_DIV},
        {OP_ADD},
        {OP_PUSH7, 0x11000100040000_bytes32},
        {OP_SSTORE},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x02_bytes32},
        {OP_DIV},
        {OP_ADD},
        {OP_PUSH7, 0x11000100040001_bytes32},
        {OP_SSTORE},
        {OP_PUSH1, 0x03_bytes32},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x02_bytes32},
        {OP_SDIV},
        {OP_ADD},
        {OP_PUSH7, 0x11000100050000_bytes32},
        {OP_SSTORE},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x01_bytes32},
        {OP_PUSH1, 0x02_bytes32},
        {OP_SDIV},
        {OP_ADD},
        {OP_PUSH7, 0x11000100050001_bytes32},
        {OP_SSTORE},
        {OP_PUSH1, 0x03_bytes32},
        {OP_PUSH1, 0x01_bytes32},
    };
    EXPECT_EQ(opcodes, expected_opcodes);
}

TEST(Tokenizer, PushOps)
{
    /**
     * byte_code generated by pasting output of the following python script
     // clang-format off
     ```
     import secrets
     for i in range(33):
        print('PUSH{} {}'.format(i, '' if i == 0 else '0x' + secrets.token_bytes(i).hex())
     ```
     // clang-format on
     * into https://www.evm.codes/playground mnemonic section and converting to
     * bytecode
     */
    auto const byte_code =
        evmc::from_hex(
            "5f60e761a68e622886c16349c278f964a48f84609865031829a68b2d664a38fc3d"
            "c6369a674ab8ff9898ee34cc681b9d8b7d039b7b8c8669dddcaa0c6628b9973543"
            "6aec0c564e55b637f0fadcc66b2f55dfef65a1f5756a3694096c763270bb7cfe72"
            "2b2ec0d3c32f6d0f5a8000818a9db6a4e9715af3106e8cfb2220f99ae5783e1770"
            "9c83e14c6f65faddd2b1495b1e708e0c223b517f27706c41632a30f88d18f41795"
            "a0cbbbdf187a71e1e2f42bdc0cd5a51184ec4d52380d6e0d4d7212a76d2274aa01"
            "74d08fbff699107a3d0018f5736472c7f147a54150845bb324420218219690b037"
            "7476c54f129d9b774767ba406c13351ac7b50f480fb7755288ff2511298508578e"
            "859eb034b7a74863f27a537c76914b80c78105631425ea69434ef16d99b1370749"
            "8a0a00775c6571f7426aad9ffd1e67a8c0703dc09d1914b7edfd2ca07817366d54"
            "e8d831ba39f6e26d11450142ef6bb8b4ec1cda8810790dfd244aa804e6b2951321"
            "83dabf879835d872fec74f9bb26c257a827d099e6f0a3598d481bdc3fec2101cd8"
            "320a48b56df0247efb2c7be47e0d26db671d12c0bee4c895192ad949205e02a2ef"
            "16a80f8357287c6c084ccdabb7a7cc35e4607fb1ad0b9a6cb7c7fd73efa9472f44"
            "5f01a47d16d91284d13e95262d7e79aea127e35155d317fd0636139770345f600b"
            "6e7e851f5cc5a55b860ead431a2de3254cca78724c44c5cf97fd02c312c6b5197e"
            "7f9d047e3657917fa48f3499ac4aa1eb343875a594c8d46e50fb46aa3ad7c6d00"
            "f")
            .value();

    auto const opcodes = monad::execution::tokenize_code(byte_code);
    std::vector<monad::execution::Instruction> expected_opcodes{
        {OP_PUSH0},
        {OP_PUSH1, 0xe7_bytes32},
        {OP_PUSH2, 0xa68e_bytes32},
        {OP_PUSH3, 0x2886c1_bytes32},
        {OP_PUSH4, 0x49c278f9_bytes32},
        {OP_PUSH5, 0xa48f846098_bytes32},
        {OP_PUSH6, 0x031829a68b2d_bytes32},
        {OP_PUSH7, 0x4a38fc3dc6369a_bytes32},
        {OP_PUSH8, 0x4ab8ff9898ee34cc_bytes32},
        {OP_PUSH9, 0x1b9d8b7d039b7b8c86_bytes32},
        {OP_PUSH10, 0xdddcaa0c6628b9973543_bytes32},
        {OP_PUSH11, 0xec0c564e55b637f0fadcc6_bytes32},
        {OP_PUSH12, 0x2f55dfef65a1f5756a369409_bytes32},
        {OP_PUSH13, 0x763270bb7cfe722b2ec0d3c32f_bytes32},
        {OP_PUSH14, 0x0f5a8000818a9db6a4e9715af310_bytes32},
        {OP_PUSH15, 0x8cfb2220f99ae5783e17709c83e14c_bytes32},
        {OP_PUSH16, 0x65faddd2b1495b1e708e0c223b517f27_bytes32},
        {OP_PUSH17, 0x6c41632a30f88d18f41795a0cbbbdf187a_bytes32},
        {OP_PUSH18, 0xe1e2f42bdc0cd5a51184ec4d52380d6e0d4d_bytes32},
        {OP_PUSH19, 0x12a76d2274aa0174d08fbff699107a3d0018f5_bytes32},
        {OP_PUSH20, 0x6472c7f147a54150845bb324420218219690b037_bytes32},
        {OP_PUSH21, 0x76c54f129d9b774767ba406c13351ac7b50f480fb7_bytes32},
        {OP_PUSH22, 0x5288ff2511298508578e859eb034b7a74863f27a537c_bytes32},
        {OP_PUSH23, 0x914b80c78105631425ea69434ef16d99b13707498a0a00_bytes32},
        {OP_PUSH24, 0x5c6571f7426aad9ffd1e67a8c0703dc09d1914b7edfd2ca0_bytes32},
        {OP_PUSH25,
         0x17366d54e8d831ba39f6e26d11450142ef6bb8b4ec1cda8810_bytes32},
        {OP_PUSH26,
         0x0dfd244aa804e6b295132183dabf879835d872fec74f9bb26c25_bytes32},
        {OP_PUSH27,
         0x827d099e6f0a3598d481bdc3fec2101cd8320a48b56df0247efb2c_bytes32},
        {OP_PUSH28,
         0xe47e0d26db671d12c0bee4c895192ad949205e02a2ef16a80f835728_bytes32},
        {OP_PUSH29,
         0x6c084ccdabb7a7cc35e4607fb1ad0b9a6cb7c7fd73efa9472f445f01a4_bytes32},
        {OP_PUSH30,
         0x16d91284d13e95262d7e79aea127e35155d317fd0636139770345f600b6e_bytes32},
        {OP_PUSH31,
         0x851f5cc5a55b860ead431a2de3254cca78724c44c5cf97fd02c312c6b5197e_bytes32},
        {OP_PUSH32,
         0x9d047e3657917fa48f3499ac4aa1eb343875a594c8d46e50fb46aa3ad7c6d00f_bytes32}};
    EXPECT_EQ(opcodes, expected_opcodes);
}

TEST(Tokenizer, AttemptReadPastCodeEnd)
{
    // a PUSH3 opcode followed by an immediate that is only 2 bytes
    auto const byte_code = evmc::from_hex("622886").value();
    EXPECT_THROW(
        monad::execution::tokenize_code(byte_code), std::invalid_argument);
}
